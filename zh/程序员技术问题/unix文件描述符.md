
# unix文件描述
在go语言开启一个进程
```go
proc, err := os.StartProcess(tmpPath, tmpParam, &os.ProcAttr{
		Files: []*os.File{inr, outw, outw},
	})
```
go语言中创建文件流
```go
outr, outw, err := os.Pipe()
	if err != nil {
		ProcessWsClientErr(err)
		return
	}
	defer outr.Close()
	defer outw.Close()

	inr, inw, err := os.Pipe()
	if err != nil {
		ProcessWsClientErr(err)
		return
	}
	defer inr.Close()
	defer inw.Close()
```
### 问题：主进程关闭的文件描述符不会影响其他进程的嘛？为什么？
在 Unix 系统中，当一个进程 fork 出一个子进程时，子进程会继承父进程的所有文件描述符。这意味着，在子进程中可以访问父进程打开的所有文件和管道。

但是，每个进程都有自己独立的文件描述符表。这意味着，即使两个进程共享同一个文件或管道，它们也拥有各自独立的文件描述符。因此，当一个进程关闭它自己的文件描述符时，并不会影响其他进程对该文件或管道的访问。

在这段代码中，我们使用 os.StartProcess 函数来启动一个新的子进程。在启动子进程时，我们将 inr、outw 和 outw 三个文件描述符传递给了子进程。这意味着，在子进程中可以通过这些文件描述符来访问相应的管道。

而在主进程中，我们关闭了 inr 和 outw 这两个文件描述符。但是这并不会影响子进程

### 问题： 不关闭的话会怎么样，有什么样的后果影响？
如果不关闭这些不再需要使用的文件描述符，可能会导致一些问题。

首先，每个进程都有一个文件描述符限制。如果进程打开了太多的文件描述符而没有关闭它们，那么最终可能会达到这个限制，导致无法再打开新的文件或管道。

其次，在这段代码中，我们使用了管道来在进程之间传输数据。当一个管道的写入端全部关闭时，读取端会读取到 EOF（即文件结束标志）。这通常用于表示写入端已经完成写入，并且不会再有新的数据到来。

但是，如果我们不关闭主进程中的 outw 文件描述符，那么即使子进程已经完成写入并关闭了它自己的 outw 文件描述符，读取端（即 outr）也不会读取到 EOF。因为仍然有一个写入端（即主进程中的 outw）没有关闭。这可能会导致读取端一直等待新的数据到来，而无法正常结束。

所以，在处理完毕后及时关闭不再需要使用的文件描述符是一个好习惯。